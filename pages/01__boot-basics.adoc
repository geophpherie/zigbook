////
changes: ["Initial draft for Boot & Basics chapter"]
examples_compile: yes
keywords: ["basics", "entry-point", "printing"]
last_updated: 2025-11-01
last_verified: 2025-11-01
next_chapter: "02__control-flow-essentials"
open_questions: []
previous_chapter: null
status: reviewed
xref_complete: true
////

= Boot & Basics
:chapter-number: 1
:chapter-slug: boot-basics
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Zig treats every source file as a namespaced module, and the compilation model revolves around explicitly wiring those units together with `@import`, keeping dependencies and program boundaries discoverable at a glance, as described in link:https://ziglang.org/documentation/master/#Compilation-Model[#Compilation Model]. This chapter builds the first mile of that journey by showing how the root module, `std`, and `builtin` cooperate to produce a runnable program from a single file while preserving explicit control over targets and optimization modes.

We also establish the ground rules for data and execution: how `const` and `var` guide mutability, why literals such as `void {}` matter for API design, how Zig handles default overflow, and how to select the right printing surface for the job, as described in link:https://ziglang.org/documentation/master/#Values[#Values]. Along the way, we preview the release mode variants and buffered output helpers you will rely on in later chapters; see link:https://ziglang.org/documentation/master/#Build-Mode[#Build-Mode].

[[learning-goals]]
== Learning Goals

* Explain how Zig resolves modules through `@import` and the role of the root namespace.
* Describe how `std.start` discovers `main` and why entry points commonly return `!void`, as described in link:https://ziglang.org/documentation/master/#Entry-Point[#Entry Point].
* Use `const`, `var`, and literal forms such as `void {}` to express intent about mutability and unit values.
* Choose between `std.debug.print`, unbuffered writers, and buffered stdout depending on the output channel and performance needs.

[[section-1]]
== Starting from a Single Source File

The fastest way to get something on screen in Zig is to lean on the default module graph: the root file you compile becomes the canonical namespace, and `@import` lets you reach everything from the standard library to compiler metadata. You will use these hooks constantly to align runtime behavior with build-time decisions.

== Entry Point Selection

The Zig compiler exports different entry point symbols based on the target platform, linking mode, and user declarations. This selection happens at compile time in link:[https://github.com/ziglang/zig/blob/master/lib/std/start.zig#L28-104].

=== Entry Point Symbol Table

|===
| Platform | Link Mode | Conditions | Exported Symbol | Handler Function

| POSIX/Linux
| Executable
| Default
| `_start`
| `_start()`

| POSIX/Linux
| Executable
| Linking libc
| `main`
| `main()`

| Windows
| Executable
| Default
| `wWinMainCRTStartup`
| `WinStartup()` / `wWinMainCRTStartup()`

| Windows
| Dynamic Library
| Default
| `_DllMainCRTStartup`
| `_DllMainCRTStartup()`

| UEFI
| Executable
| Default
| `EfiMain`
| `EfiMain()`

| WASI
| Executable (command)
| Default
| `_start`
| `wasi_start()`

| WASI
| Executable (reactor)
| Default
| `_initialize`
| `wasi_start()`

| WebAssembly
| Freestanding
| Default
| `_start`
| `wasm_freestanding_start()`

| WebAssembly
| Linking libc
| Default
| `__main_argc_argv`
| `mainWithoutEnv()`

| OpenCL/Vulkan
| Kernel
| Default
| `main`
| `spirvMain2()`

| MIPS
| Any
| Default
| `__start`
| (same as `_start`)
|===

=== Compile-Time Entry Point Logic

[mermaid]
....
graph TB
    Start["comptime block<br/>(start.zig:28)"]
    CheckMode["Check builtin.output_mode"]
    CheckSimplified["simplified_logic?<br/>(stage2 backends)"]

    CheckLinkC["link_libc or<br/>object_format == .c?"]
    CheckWindows["builtin.os == .windows?"]
    CheckUEFI["builtin.os == .uefi?"]
    CheckWASI["builtin.os == .wasi?"]
    CheckWasm["arch.isWasm() &&<br/>os == .freestanding?"]

    ExportMain["@export(&main, 'main')"]
    ExportWinMain["@export(&WinStartup,<br/>'wWinMainCRTStartup')"]
    ExportStart["@export(&_start, '_start')"]
    ExportEfi["@export(&EfiMain, 'EfiMain')"]
    ExportWasi["@export(&wasi_start,<br/>wasm_start_sym)"]
    ExportWasmStart["@export(&wasm_freestanding_start,<br/>'_start')"]

    Start --> CheckMode
    CheckMode -->|".Exe or has main"| CheckSimplified
    CheckSimplified -->|"true"| Simple["Simplified logic<br/>(lines 33-51)"]
    CheckSimplified -->|"false"| CheckLinkC

    CheckLinkC -->|"yes"| ExportMain
    CheckLinkC -->|"no"| CheckWindows
    CheckWindows -->|"yes"| ExportWinMain
    CheckWindows -->|"no"| CheckUEFI
    CheckUEFI -->|"yes"| ExportEfi
    CheckUEFI -->|"no"| CheckWASI
    CheckWASI -->|"yes"| ExportWasi
    CheckWASI -->|"no"| CheckWasm
    CheckWasm -->|"yes"| ExportWasmStart
    CheckWasm -->|"no"| ExportStart
....


[[section-1-sub-a]]
=== Modules and Imports

The root module is just your top-level file, so any declarations you mark `pub` are immediately re-importable under `@import("root")`. Pair that with `@import("builtin")` to inspect the target chosen by your current compiler invocation, as described in link:https://ziglang.org/documentation/master/#Builtin-Functions[#Builtin-Functions].

[source,zig]
----

include::{sourcedir}/01__boot-basics/imports.zig[]

----

.Run
[source,shell]
----
$ zig run imports.zig
----

.Output
[source,shell]
----
app: Boot Basics Tour
optimize mode: Debug
target: x86_64-linux-gnu
----

Actual target identifiers depend on your host triple; the important part is seeing how `@tagName` exposes each enum so you can branch on them later.

Because the buffered stdout writer batches data, always call `flush()` before exiting so the terminal receives the final line.

TIP: Reach for `@import("root")` to surface configuration constants without baking extra globals into your namespace.

[[section-1-sub-b]]
=== Entry Points and Early Errors

Zig's runtime glue (`std.start`) looks for a `pub fn main`, forwards command-line state, and treats an error return as a signal to abort with diagnostics. Because `main` commonly performs I/O, giving it the `!void` return type keeps error propagation explicit.

[source,zig]
----

include::{sourcedir}/01__boot-basics/entry_point.zig[]

----

.Run
[source,shell]
----
$ zig run entry_point.zig
----

.Output
[source,shell]
----
Zig entry point reporting in.
----

In release modes (`zig run -OReleaseFast ...`), the `ModeError.ReleaseOnly` branch fires and the warning surfaces before the program continues, neatly demonstrating how `catch` converts errors into user-facing diagnostics without suppressing later work.

[[section-1-sub-b2]]
=== How `main()` Return Types Are Handled

Zig's startup code in `std.start` inspects your `main()` function's return type at compile time and generates appropriate handling logic. This flexibility allows you to choose the signature that best fits your program's needs—whether you want simple success/failure semantics with `!void`, explicit exit codes with `u8`, or an infinite event loop with `noreturn`. The `callMain()` function orchestrates this dispatch, ensuring errors are logged and exit codes propagate correctly to the operating system.

==== callMain Return Type Handling

The `callMain()` function handles different return type signatures from the user's `main()`:

[mermaid]
....
graph TB
    Start["callMain()"]

    GetRetType["ReturnType = @TypeOf(root.main)<br/>.return_type"]

    CheckType["switch ReturnType"]

    Void["void"]
    CallVoid["root.main()<br/>return 0"]

    NoReturn["noreturn"]
    CallNoReturn["return root.main()"]

    U8["u8"]
    CallU8["return root.main()"]

    ErrorUnion["error union"]

    CheckInner["@TypeOf(result)?"]

    InnerVoid["void"]
    ReturnZero["return 0"]

    InnerU8["u8"]
    ReturnResult["return result"]

    Invalid["@compileError"]

    CallCatch["result = root.main()<br/>catch |err|"]

    LogError["Log error name<br/>and stack trace<br/>(lines 707-712)"]

    ReturnOne["return 1"]

    Start --> GetRetType
    GetRetType --> CheckType
    CheckType --> Void
    CheckType --> NoReturn
    CheckType --> U8
    CheckType --> ErrorUnion
    CheckType --> Invalid

    Void --> CallVoid
    NoReturn --> CallNoReturn
    U8 --> CallU8

    ErrorUnion --> CallCatch
    CallCatch --> CheckInner
    CallCatch --> LogError
    LogError --> ReturnOne

    CheckInner --> InnerVoid
    CheckInner --> InnerU8
    CheckInner --> Invalid

    InnerVoid --> ReturnZero
    InnerU8 --> ReturnResult
....

Valid return types from `main()`:

* `void` - Returns exit code 0
* `noreturn` - Never returns (infinite loop or explicit exit)
* `u8` - Returns exit code directly
* `!void` - Returns 0 on success, 1 on error (logs error with stack trace)
* `!u8` - Returns exit code on success, 1 on error (logs error with stack trace)

The `!void` signature used in our examples provides the best balance: explicit error handling with automatic logging and appropriate exit codes.

[[section-1-sub-c]]
=== Naming and Scope Preview

Variables obey lexical scope: every block introduces a new region where you may shadow or extend bindings, while `const` and `var` signal immutability versus mutability and help the compiler reason about safety, as described in link:https://ziglang.org/documentation/master/#Blocks[#Blocks]. Zig defers a deeper discussion of style and shadowing to Chapter 38, but keep in mind that thoughtful naming at the top level (often via `pub const`) is the idiomatic way to share configuration between files; see link:https://ziglang.org/documentation/master/#Variables[#Variables].

[[section-2]]
== Working with Values and Builds

Once you have an entry point, the next stop is data: numeric types come in explicitly sized flavors (`iN`, `uN`, `fN`), literals infer their type from context, and Zig uses debug safety checks to trap overflows unless you opt into wrapping or saturating operators. Build modes (`-O` flags) decide which checks remain in place and how aggressively the compiler optimizes.

[[section-2-sub-a]]
=== Optimization Modes

Zig provides four optimization modes that control the trade-offs between code speed, binary size, and safety checks:

|===
| Mode | Priority | Safety Checks | Speed | Binary Size | Use Case

| `Debug`
| Safety + Debug Info
| ✓ All enabled
| Slowest
| Largest
| Development and debugging

| `ReleaseSafe`
| Speed + Safety
| ✓ All enabled
| Fast
| Large
| Production with safety

| `ReleaseFast`
| Maximum Speed
| ✗ Disabled
| Fastest
| Medium
| Performance-critical production

| `ReleaseSmall`
| Minimum Size
| ✗ Disabled
| Fast
| Smallest
| Embedded systems, size-constrained
|===

The optimization mode is specified via the `-O` flag and affects:

* Runtime safety checks (overflow, bounds checking, null checks)
* Stack traces and debug information generation
* LLVM optimization level (when using the LLVM backend)
* Inlining heuristics and code generation strategies

[mermaid]
....
graph TB
    subgraph "Optimization Mode Effects"
        OptMode["optimize_mode: OptimizeMode"]

        OptMode --> SafetyChecks["Runtime Safety Checks"]
        OptMode --> DebugInfo["Debug Information"]
        OptMode --> CodegenStrategy["Codegen Strategy"]
        OptMode --> LLVMOpt["LLVM Optimization Level"]

        SafetyChecks --> Overflow["Integer overflow checks"]
        SafetyChecks --> Bounds["Bounds checking"]
        SafetyChecks --> Null["Null pointer checks"]
        SafetyChecks --> Unreachable["Unreachable assertions"]

        DebugInfo --> StackTraces["Stack traces"]
        DebugInfo --> DWARF["DWARF debug info"]
        DebugInfo --> LineInfo["Source line information"]

        CodegenStrategy --> Inlining["Inlining heuristics"]
        CodegenStrategy --> Unrolling["Loop unrolling"]
        CodegenStrategy --> Vectorization["SIMD vectorization"]

        LLVMOpt --> O0["Debug: -O0"]
        LLVMOpt --> O2Safe["ReleaseSafe: -O2 + safety"]
        LLVMOpt --> O3["ReleaseFast: -O3"]
        LLVMOpt --> Oz["ReleaseSmall: -Oz"]
    end
....

In this chapter we use `Debug` (the default) for development and preview `ReleaseFast` to demonstrate how optimization choices affect behavior and binary characteristics.

[[workflow-1]]
=== Values, Literals, and Debug Printing

`std.debug.print` writes to stderr and is perfect for early experiments; it accepts any value you throw at it, revealing how `@TypeOf` and friends reflect on literals.

[source,zig]
----
include::{sourcedir}/01__boot-basics/values_and_literals.zig[]

----

.Run
[source,shell]
----
$ zig run values_and_literals.zig
----

.Output
[source,shell]
----
counter=3 ratio=0.5 safety=true
newline byte=10 (ASCII)
unit literal has type void
----

Treat `void {}` as a communicative literal indicating "nothing to configure," and remember that debug prints default to stderr so they never interfere with stdout pipelines.

[[workflow-2]]
=== Buffering stdout and Build Modes

When you want deterministic stdout with fewer syscalls, borrow a buffer and flush once—especially in release profiles where throughput matters. The example below shows how to set up a buffered writer around `std.fs.File.stdout()` and highlights the differences between build modes.

[source,zig]
----

include::{sourcedir}/01__boot-basics/buffered_stdout.zig[]

----

.Run
[source,shell]
----
$ zig build-exe buffered_stdout.zig -OReleaseFast
$
$ ./buffered_stdout
----

.Output
[source,shell]
----
Buffering saves syscalls.
Flush once at the end.
----

Using a buffered writer mirrors the standard library's own initialization template and keeps writes cohesive; always flush before exiting to guarantee the OS sees your final message.

[[notes-caveats]]
== Notes & Caveats

* `std.debug.print` targets stderr and bypasses stdout buffering, so reserve it for diagnostics even in simple tools.
* Wrapping (`+%`) and saturating (`+|`) arithmetic are available when you deliberately want to skip overflow traps; the default operators still panic in Debug mode to catch mistakes early, as documented in link:https://ziglang.org/documentation/master/#Operators[#Operators].
* `std.fs.File.stdout().writer(&buffer)` mirrors the patterns used by `zig init` and requires an explicit `flush()` to push buffered bytes downstream.

[[exercises]]
== Exercises

* Extend `imports.zig` to print the pointer size reported by `@sizeOf(usize)` and compare targets by toggling `-Dtarget` values on the command line.
* Refactor `entry_point.zig` so that `requireDebugSafety` returns a descriptive error union (`error{ReleaseOnly}![]const u8`) and have `main` write the message to stdout before rethrowing.
* Build `buffered_stdout.zig` with `-OReleaseSafe` and `-OReleaseSmall`, measuring the binary sizes to see how optimization choices impact deployment footprints.
